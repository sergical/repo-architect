import { mkdir, writeFile, readFile } from 'node:fs/promises';
import path from 'node:path';
const DOCS_DIR = 'docs/architecture';
export async function renderFullDocs(repoRoot, analysis) {
    const docsDir = path.join(repoRoot, DOCS_DIR);
    const modulesDir = path.join(docsDir, 'modules');
    await mkdir(modulesDir, { recursive: true });
    const writtenFiles = [];
    const overview = renderOverview(analysis);
    const overviewPath = path.join(docsDir, 'OVERVIEW.md');
    await writeFile(overviewPath, overview);
    writtenFiles.push(overviewPath);
    for (const mod of analysis.modules) {
        const moduleDoc = renderModule(mod);
        const safeName = mod.name.toLowerCase().replace(/[^a-z0-9]+/g, '-');
        const modulePath = path.join(modulesDir, `${safeName}.md`);
        await writeFile(modulePath, moduleDoc);
        writtenFiles.push(modulePath);
    }
    return writtenFiles;
}
export async function renderIncrementalDocs(repoRoot, analysis) {
    const docsDir = path.join(repoRoot, DOCS_DIR);
    const modulesDir = path.join(docsDir, 'modules');
    await mkdir(modulesDir, { recursive: true });
    const writtenFiles = [];
    if (analysis.updatedOverview || analysis.updatedSystemMap || analysis.updatedDataFlows || analysis.updatedDependencyGraph) {
        const overviewPath = path.join(docsDir, 'OVERVIEW.md');
        let existing = '';
        try {
            existing = await readFile(overviewPath, 'utf-8');
        }
        catch {
            // file doesn't exist yet
        }
        let updated = existing;
        if (analysis.updatedOverview) {
            updated = replaceSection(updated, 'Overview', analysis.updatedOverview);
        }
        if (analysis.updatedSystemMap) {
            updated = replaceSection(updated, 'System Map', analysis.updatedSystemMap);
        }
        if (analysis.updatedDataFlows) {
            updated = replaceSection(updated, 'Data Flows', analysis.updatedDataFlows);
        }
        if (analysis.updatedDependencyGraph) {
            updated = replaceSection(updated, 'Dependency Graph', analysis.updatedDependencyGraph);
        }
        if (updated === existing && analysis.updatedOverview) {
            updated = analysis.updatedOverview;
        }
        await writeFile(overviewPath, updated);
        writtenFiles.push(overviewPath);
    }
    for (const mod of [...analysis.updatedModules, ...analysis.newModules]) {
        const moduleDoc = renderModule(mod);
        const safeName = mod.name.toLowerCase().replace(/[^a-z0-9]+/g, '-');
        const modulePath = path.join(modulesDir, `${safeName}.md`);
        await writeFile(modulePath, moduleDoc);
        writtenFiles.push(modulePath);
    }
    return writtenFiles;
}
function renderOverview(analysis) {
    const sections = [
        `# ${analysis.projectName} - Architecture Overview`,
        '',
        `> Auto-generated by repo-architect on ${new Date().toISOString().split('T')[0]}`,
        '',
        '## Overview',
        '',
        analysis.overview,
        '',
    ];
    if (analysis.techStack.length > 0) {
        sections.push('## Tech Stack', '', ...analysis.techStack.map(t => `- ${t}`), '');
    }
    if (analysis.systemMap) {
        sections.push('## System Map', '', '```mermaid', analysis.systemMap, '```', '');
    }
    if (analysis.dataFlows) {
        sections.push('## Data Flows', '', '```mermaid', analysis.dataFlows, '```', '');
    }
    if (analysis.dependencyGraph) {
        sections.push('## Dependency Graph', '', '```mermaid', analysis.dependencyGraph, '```', '');
    }
    if (analysis.modules.length > 0) {
        sections.push('## Modules', '', '| Module | Path | Description |', '|--------|------|-------------|', ...analysis.modules.map(m => `| [${m.name}](modules/${m.name.toLowerCase().replace(/[^a-z0-9]+/g, '-')}.md) | \`${m.path}\` | ${m.description} |`), '');
    }
    return sections.join('\n');
}
function renderModule(mod) {
    const sections = [
        `# ${mod.name}`,
        '',
        `> Path: \`${mod.path}\``,
        '',
        mod.description,
        '',
    ];
    if (mod.keyAbstractions.length > 0) {
        sections.push('## Key Abstractions', '', ...mod.keyAbstractions.map(a => `- ${a}`), '');
    }
    if (mod.internalDiagram) {
        sections.push('## Internal Structure', '', '```mermaid', mod.internalDiagram, '```', '');
    }
    return sections.join('\n');
}
function replaceSection(doc, sectionName, newContent) {
    const regex = new RegExp(`(## ${sectionName}\\s*\\n)((?:(?!## ).)*)`, 's');
    const match = doc.match(regex);
    if (match) {
        return doc.replace(regex, `$1\n${newContent}\n\n`);
    }
    return doc;
}
//# sourceMappingURL=render.js.map