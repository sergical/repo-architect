import { mkdir, writeFile, readFile, unlink } from 'node:fs/promises';
import path from 'node:path';
import type { AnalysisResult, IncrementalAnalysisResult, ModuleAnalysis } from './analyze.js';

export interface IncrementalRenderResult {
  writtenFiles: string[];
  deletedFiles: string[];
}

const DEFAULT_DOCS_DIR = 'docs/architecture';

export async function renderFullDocs(repoRoot: string, analysis: AnalysisResult, outputDir?: string): Promise<string[]> {
  const docsDir = path.join(repoRoot, outputDir ?? DEFAULT_DOCS_DIR);
  const modulesDir = path.join(docsDir, 'modules');
  await mkdir(modulesDir, { recursive: true });

  const writtenFiles: string[] = [];

  const overview = renderOverview(analysis);
  const overviewPath = path.join(docsDir, 'OVERVIEW.md');
  await writeFile(overviewPath, overview);
  writtenFiles.push(overviewPath);

  for (const mod of analysis.modules) {
    const moduleDoc = renderModule(mod);
    const safeName = mod.name.toLowerCase().replace(/[^a-z0-9]+/g, '-');
    const modulePath = path.join(modulesDir, `${safeName}.md`);
    await writeFile(modulePath, moduleDoc);
    writtenFiles.push(modulePath);
  }

  return writtenFiles;
}

export async function renderIncrementalDocs(
  repoRoot: string,
  analysis: IncrementalAnalysisResult,
  outputDir?: string,
): Promise<IncrementalRenderResult> {
  const docsDir = path.join(repoRoot, outputDir ?? DEFAULT_DOCS_DIR);
  const modulesDir = path.join(docsDir, 'modules');
  await mkdir(modulesDir, { recursive: true });

  const writtenFiles: string[] = [];
  const deletedFiles: string[] = [];

  if (analysis.updatedOverview || analysis.updatedSystemMap || analysis.updatedDataFlows || analysis.updatedDependencyGraph) {
    const overviewPath = path.join(docsDir, 'OVERVIEW.md');
    let existing = '';
    try {
      existing = await readFile(overviewPath, 'utf-8');
    } catch {
      // file doesn't exist yet
    }

    let updated = existing;
    if (analysis.updatedOverview) {
      updated = replaceSection(updated, 'Overview', analysis.updatedOverview);
    }
    if (analysis.updatedSystemMap) {
      updated = replaceSection(updated, 'System Map', analysis.updatedSystemMap);
    }
    if (analysis.updatedDataFlows) {
      updated = replaceSection(updated, 'Data Flows', analysis.updatedDataFlows);
    }
    if (analysis.updatedDependencyGraph) {
      updated = replaceSection(updated, 'Dependency Graph', analysis.updatedDependencyGraph);
    }

    await writeFile(overviewPath, updated);
    writtenFiles.push(overviewPath);
  }

  for (const mod of [...analysis.updatedModules, ...analysis.newModules]) {
    const moduleDoc = renderModule(mod);
    const safeName = mod.name.toLowerCase().replace(/[^a-z0-9]+/g, '-');
    const modulePath = path.join(modulesDir, `${safeName}.md`);
    await writeFile(modulePath, moduleDoc);
    writtenFiles.push(modulePath);
  }

  // Delete orphaned module files
  for (const name of analysis.deletedModules) {
    const safeName = name.toLowerCase().replace(/[^a-z0-9]+/g, '-');
    const modulePath = path.join(modulesDir, `${safeName}.md`);
    try {
      await unlink(modulePath);
      deletedFiles.push(modulePath);
    } catch {
      // file may not exist
    }
  }

  return { writtenFiles, deletedFiles };
}

function renderOverview(analysis: AnalysisResult): string {
  const sections: string[] = [
    `# ${analysis.projectName} - Architecture Overview`,
    '',
    `> Auto-generated by repo-architect on ${new Date().toISOString().split('T')[0]}`,
    '',
    '## Overview',
    '',
    analysis.overview,
    '',
  ];

  if (analysis.techStack.length > 0) {
    sections.push(
      '## Tech Stack',
      '',
      ...analysis.techStack.map(t => `- ${t}`),
      '',
    );
  }

  if (analysis.systemMap) {
    sections.push(
      '## System Map',
      '',
      '```mermaid',
      analysis.systemMap,
      '```',
      '',
    );
  }

  if (analysis.dataFlows) {
    sections.push(
      '## Data Flows',
      '',
      '```mermaid',
      analysis.dataFlows,
      '```',
      '',
    );
  }

  if (analysis.dependencyGraph) {
    sections.push(
      '## Dependency Graph',
      '',
      '```mermaid',
      analysis.dependencyGraph,
      '```',
      '',
    );
  }

  if (analysis.modules.length > 0) {
    sections.push(
      '## Modules',
      '',
      '| Module | Path | Description |',
      '|--------|------|-------------|',
      ...analysis.modules.map(m =>
        `| [${m.name}](modules/${m.name.toLowerCase().replace(/[^a-z0-9]+/g, '-')}.md) | \`${m.path}\` | ${m.description} |`
      ),
      '',
    );
  }

  return sections.join('\n');
}

function renderModule(mod: ModuleAnalysis): string {
  const sections: string[] = [
    `# ${mod.name}`,
    '',
    `> Path: \`${mod.path}\``,
    '',
    mod.description,
    '',
  ];

  if (mod.keyAbstractions.length > 0) {
    sections.push(
      '## Key Abstractions',
      '',
      ...mod.keyAbstractions.map(a => `- ${a}`),
      '',
    );
  }

  if (mod.internalDiagram) {
    sections.push(
      '## Internal Structure',
      '',
      '```mermaid',
      mod.internalDiagram,
      '```',
      '',
    );
  }

  return sections.join('\n');
}

export function replaceSection(doc: string, sectionName: string, newContent: string): string {
  if (!doc.trim()) {
    return `## ${sectionName}\n\n${newContent}\n`;
  }

  // Split document into sections by ## headers
  const lines = doc.split('\n');
  const sections: { header: string; content: string; startIndex: number }[] = [];
  let currentHeader = '';
  let currentLines: string[] = [];
  let currentStart = 0;

  for (let i = 0; i < lines.length; i++) {
    if (lines[i].startsWith('## ')) {
      if (currentHeader || currentLines.length > 0) {
        sections.push({ header: currentHeader, content: currentLines.join('\n'), startIndex: currentStart });
      }
      currentHeader = lines[i].replace(/^## /, '').trim();
      currentStart = i;
      currentLines = [];
    } else {
      currentLines.push(lines[i]);
    }
  }
  // Push final section
  sections.push({ header: currentHeader, content: currentLines.join('\n'), startIndex: currentStart });

  // Find section case-insensitively
  const matchIdx = sections.findIndex(s => s.header.toLowerCase() === sectionName.toLowerCase());

  if (matchIdx !== -1) {
    // Replace matching section content
    const result: string[] = [];
    for (let i = 0; i < sections.length; i++) {
      if (i === matchIdx) {
        result.push(`## ${sections[i].header}\n\n${newContent}\n`);
      } else {
        if (sections[i].header) {
          result.push(`## ${sections[i].header}${sections[i].content}`);
        } else {
          result.push(sections[i].content);
        }
      }
    }
    return result.join('\n');
  }

  // Section not found â€” append it
  const trimmed = doc.trimEnd();
  return `${trimmed}\n\n## ${sectionName}\n\n${newContent}\n`;
}
