var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import path from 'node:path';
import { z } from 'zod';
import { runCli } from '../../cli/cliRun.js';
import { buildMcpToolErrorResponse, createToolWorkspace, formatToolError, formatToolResponse, } from './mcpToolRuntime.js';
export const registerPackRemoteRepositoryTool = (mcpServer) => {
    mcpServer.tool('pack_remote_repository', 'Fetch, clone, and package a GitHub repository into a consolidated XML file for AI analysis. This tool automatically clones the remote repository, analyzes its structure, and generates a comprehensive report. Supports various GitHub URL formats and includes security checks to prevent exposure of sensitive information.', {
        remote: z
            .string()
            .describe('GitHub repository URL or user/repo format (e.g., "yamadashy/repomix", "https://github.com/user/repo", or "https://github.com/user/repo/tree/branch")'),
        compress: z
            .boolean()
            .default(false)
            .describe('Enable Tree-sitter compression to extract essential code signatures and structure while removing implementation details. Reduces token usage by ~70% while preserving semantic meaning. Generally not needed since grep_repomix_output allows incremental content retrieval. Use only when you specifically need the entire codebase content for large repositories (default: false).'),
        includePatterns: z
            .string()
            .optional()
            .describe('Specify files to include using fast-glob patterns. Multiple patterns can be comma-separated (e.g., "**/*.{js,ts}", "src/**,docs/**"). Only matching files will be processed. Useful for focusing on specific parts of the codebase.'),
        ignorePatterns: z
            .string()
            .optional()
            .describe('Specify additional files to exclude using fast-glob patterns. Multiple patterns can be comma-separated (e.g., "test/**,*.spec.js", "node_modules/**,dist/**"). These patterns supplement .gitignore and built-in exclusions.'),
        topFilesLength: z
            .number()
            .optional()
            .default(10)
            .describe('Number of largest files by size to display in the metrics summary for codebase analysis (default: 10)'),
    }, {
        title: 'Pack Remote Repository',
        readOnlyHint: true,
        destructiveHint: false,
        idempotentHint: false,
        openWorldHint: true,
    }, (_a) => __awaiter(void 0, [_a], void 0, function* ({ remote, compress, includePatterns, ignorePatterns, topFilesLength }) {
        let tempDir = '';
        try {
            tempDir = yield createToolWorkspace();
            const outputFilePath = path.join(tempDir, 'repomix-output.xml');
            const cliOptions = {
                remote,
                compress,
                include: includePatterns,
                ignore: ignorePatterns,
                output: outputFilePath,
                style: 'xml',
                securityCheck: true,
                topFilesLen: topFilesLength,
                quiet: true,
            };
            const result = yield runCli(['.'], process.cwd(), cliOptions);
            if (!result) {
                return buildMcpToolErrorResponse(['Failed to return a result']);
            }
            // Extract metrics information from the pack result
            const { packResult } = result;
            return yield formatToolResponse({ repository: remote }, packResult, outputFilePath, topFilesLength);
        }
        catch (error) {
            return formatToolError(error);
        }
    }));
};
//# sourceMappingURL=packRemoteRepositoryTool.js.map